/*
 * generated by Xtext 2.26.0
 */
package hvbargen.meth.validation;

import java.util.HashMap;
import java.util.Map;

import org.eclipse.emf.ecore.EAttribute;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.validation.Check;

import hvbargen.meth.meth.Berechnung;
import hvbargen.meth.meth.BerechnungStatement;
import hvbargen.meth.meth.Deklaration;
import hvbargen.meth.meth.Dimension;
import hvbargen.meth.meth.Eingabe;
import hvbargen.meth.meth.EingabeStatement;
import hvbargen.meth.meth.Einheit;
import hvbargen.meth.meth.EinheitExpr;
import hvbargen.meth.meth.Formel;
import hvbargen.meth.meth.Gegeben;
import hvbargen.meth.meth.GegebenStatement;
import hvbargen.meth.meth.Konstante;
import hvbargen.meth.meth.MethPackage;
import hvbargen.meth.meth.Methode;
import hvbargen.meth.meth.Model;
import hvbargen.meth.meth.Umrechnung;

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
public class MethValidator extends AbstractMethValidator {
	
	public static final String INVALID_NAME = "invalidName";
//
//	@Check
//	public void checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.getName().charAt(0))) {
//			warning("Name should start with a capital",
//					MethPackage.Literals.GREETING__NAME,
//					INVALID_NAME);
//		}
//	}
	
	private void checkSyntax(String bezeichner, EAttribute eattr) {
		char ch = bezeichner.charAt(0);
		if (ch >= 'A' && ch <= 'Z' || ch >= 'a' && ch <= 'z') {
			; // OK
		} else {
			error("Bezeichner " + bezeichner + " muss mit lat. Buchstabe anfangen", eattr, INVALID_NAME);
		}
	}

	@Check
	public void checkBezeichner(EingabeStatement e) {
		String name = e.getEingabename();
		checkSyntax(name, MethPackage.Literals.EINGABE_STATEMENT__EINGABENAME);
	}

	@Check
	public void checkBezeichner(BerechnungStatement e) {
		String name = e.getBerechnungname();
		checkSyntax(name, MethPackage.Literals.BERECHNUNG_STATEMENT__BERECHNUNGNAME);
	}
/*	
	@Check
	public void checkMethodenEindeutig(Model model) {
		bekannteMethoden.clear();
		for (Methode methode: model.getMethoden()) {
			String name = methode.getName();
			Methode vorhanden = bekannteMethoden.get(name);
			if (vorhanden != null) {
				error("Methode namens " + name + " existiert bereits", methode, MethPackage.Literals.METHODE__NAME, "DoppelteMethode");
				error("Methode namens " + name + " kommt später nochmal", vorhanden, MethPackage.Literals.METHODE__NAME, "DoppelteMethode");
			} else {
				bekannteMethoden.put(name, methode);
			}
		}
	}
*/
	@Check
	public void checkReferenzenDefiniert(Model model) {
		Map<String, Einheit> einheiten = new HashMap<String, Einheit>();
		Map<String, Konstante> konstanten = new HashMap<String, Konstante>(); 
		
		for (Deklaration dekl: model.getEinheitensystem().getDeklarationen()) {
			if (dekl instanceof Dimension) {
				;
			} else if (dekl instanceof Einheit) {
				String name = ((Einheit) dekl).getName();
				
				EinheitExpr faktor = ((Einheit)dekl).getFaktor();
				if (faktor != null) {
					for (var allContents = faktor.eAllContents(); allContents.hasNext(); ) {
						EObject element = allContents.next();
						if (element instanceof EinheitExpr) {
							String refname = ((EinheitExpr)element).getVarref();
							if (refname != null && einheiten.get(refname) == null && konstanten.get(refname) == null) {
								error("Einheit/Konstante nicht definiert: " + refname, element, MethPackage.Literals.EINHEIT_EXPR__VARREF, "UnknownUnit");
							}
						}
					}
				}				
				einheiten.put(name, (Einheit) dekl);
			} else if (dekl instanceof Umrechnung) {
				Umrechnung u = (Umrechnung) dekl;
				String varname = u.getVarname();
				if (einheiten.get(varname) != null) {
					error("Variable " + varname + " wurde bereits als Einheit deklariert!", u, MethPackage.Literals.UMRECHNUNG__VARNAME, "invalidVarName");
				}
				for (var allContents = u.getAusdruck().eAllContents(); allContents.hasNext(); ) {
					EObject element = allContents.next();
					if (element instanceof EinheitExpr) {
						String refname = ((EinheitExpr)element).getVarref();
						if (refname != null && einheiten.get(refname) == null && !refname.equals(varname) && konstanten.get(refname) == null) {
							error("Einheit/Konstante nicht definiert: " + refname, element, MethPackage.Literals.EINHEIT_EXPR__VARREF, "UnknownUnit");
						}
					}
				}
			} else if (dekl instanceof Konstante) {
				Konstante konstante = (Konstante)dekl;
				String name = konstante.getName();
				if (konstanten.get(name) != null) {
					error("Konstante " + name + " wurde bereits definiert!", konstante, MethPackage.Literals.KONSTANTE__NAME, "invalidConstName");
				} else if (einheiten.get(name) != null) {
					error("Konstante " + name + " wurde bereits als Einheit definiert!", konstante, MethPackage.Literals.KONSTANTE__NAME, "invalidConstName");
				}
				for (var allContents = konstante.getAusdruck().eAllContents(); allContents.hasNext(); ) {
					EObject element = allContents.next();
					if (element instanceof EinheitExpr) {
						String refname = ((EinheitExpr)element).getVarref();
						if (refname != null && einheiten.get(refname) == null && !refname.equals(name) && konstanten.get(refname) == null) {
							error("Einheit/Konstante nicht definiert: " + refname, element, MethPackage.Literals.EINHEIT_EXPR__VARREF, "UnknownUnit");
						}
					}
				}
			}
		}
		
		Map<String, Methode> bekannteMethoden = new HashMap<String, Methode>();
		for (Methode methode: model.getMethoden()) {
			String methodeName = methode.getName();
			Methode vorhanden = bekannteMethoden.get(methodeName);
			if (vorhanden != null) {
				error("Methode namens " + methodeName + " existiert bereits", methode, MethPackage.Literals.METHODE__NAME, "DoppelteMethode");
				error("Methode namens " + methodeName + " kommt später nochmal", vorhanden, MethPackage.Literals.METHODE__NAME, "DoppelteMethode");
			} else {
				bekannteMethoden.put(methodeName, methode);
			}
			Map<String, EObject> bekannteParameter = new HashMap<String, EObject>(); 
			for (EObject o: methode.getAblauf()) {
				if (o instanceof Gegeben) {
					for (GegebenStatement s: ((Gegeben)o).getStatements()) {
						String name = s.getEingabename();
						if (bekannteParameter.get(name) != null) {
							error("Parameter namens " + name + " existiert bereits", s, MethPackage.Literals.EINGABE_STATEMENT__EINGABENAME, "DoppelterParameter");
						} else {
							bekannteParameter.put(name, s);
						}
					}
				}
				if (o instanceof Eingabe) {
					for (EingabeStatement s: ((Eingabe)o).getStatements()) {
						String name = s.getEingabename();
						if (bekannteParameter.get(name) != null) {
							error("Parameter namens " + name + " existiert bereits", s, MethPackage.Literals.EINGABE_STATEMENT__EINGABENAME, "DoppelterParameter");
						} else {
							bekannteParameter.put(name, s);
						}
					}
				}
				if (o instanceof Berechnung) {
					for (BerechnungStatement s: ((Berechnung)o).getStatements()) {
						String name = s.getBerechnungname();
						Formel formel = s.getFormel();
						for (var allContents = formel.eAllContents(); allContents.hasNext(); ) {
							EObject element = allContents.next();
							if (element instanceof EinheitExpr) {
								String refname = ((EinheitExpr)element).getVarref();
								if (refname != null && bekannteParameter.get(refname) == null && konstanten.get(refname) == null) {
									error("Parameter nicht definiert: " + refname, element, MethPackage.Literals.EINHEIT_EXPR__VARREF, "InvalidParam");
								}
							}
							
						}
						if (bekannteParameter.get(name) != null) {
							error("Parameter namens " + name + " existiert bereits", s, MethPackage.Literals.BERECHNUNG_STATEMENT__BERECHNUNGNAME, "DoppelterParameter");
						} else {
							bekannteParameter.put(name, s);
						}
					}
				}
			}
		}
	}
	
/*	
	@Check
	public void checkBezeichnerEindeutig(Methode methode) {
		Set<String> bekannt = new HashSet<String>();
		for (EObject o: methode.getAblauf()) {
			if (o instanceof Gegeben) {
				for (GegebenStatement s: ((Gegeben)o).getStatements()) {
					String name = s.getEingabename();
					if (bekannt.contains(name)) {
						error("Parameter namens " + name + " existiert bereits", s, MethPackage.Literals.EINGABE_STATEMENT__EINGABENAME, "DoppelterParameter");
					} else {
						bekannt.add(name);
					}
				}
			}
			if (o instanceof Eingabe) {
				for (EingabeStatement s: ((Eingabe)o).getStatements()) {
					String name = s.getEingabename();
					if (bekannt.contains(name)) {
						error("Parameter namens " + name + " existiert bereits", s, MethPackage.Literals.EINGABE_STATEMENT__EINGABENAME, "DoppelterParameter");
					} else {
						bekannt.add(name);
					}
				}
			}
			if (o instanceof Berechnung) {
				for (BerechnungStatement s: ((Berechnung)o).getStatements()) {
					String name = s.getBerechnungname();
					if (bekannt.contains(name)) {
						error("Parameter namens " + name + " existiert bereits", s, MethPackage.Literals.BERECHNUNG_STATEMENT__BERECHNUNGNAME, "DoppelterParameter");
					} else {
						bekannt.add(name);
					}
				}
			}
		}
		
	}
*/
}
